defmodule EvercamMedia.TimelapseRecording.TimelapseRecordingSupervisor do
  @moduledoc """
  This supervisor creates EvercamMedia.TimelapseRecording.TimelapseRecordingWorker using the strategy
  :simple_one_for_one and can only handle one child type of children.

  Since we want to dynamically create EvercamMedia.TimelapseRecording.TimelapseRecordingWorker for the cameras,
  other types of strategies in supervisor are not suitable.

  When creating a new worker, the supervisor passes on a list of @event_handlers.
  @event_handlers are the handlers that wants to react to the events generated by
  EvercamMedia.TimelapseRecording.TimelapseRecordingWorker. These handlers are automatically added to the
  event manager for every created worker.
  """

  use Supervisor
  require Logger
  alias EvercamMedia.TimelapseRecording.TimelapseRecordingWorker

  def start_link() do
    Supervisor.start_link(__MODULE__, :ok, name: __MODULE__)
  end

  def init(:ok) do
    if Application.get_env(:evercam_media, :start_camera_workers) do
      Task.start_link(&initiate_workers/0)
    end
    children = [worker(TimelapseRecordingWorker, [], restart: :permanent)]
    supervise(children, strategy: :simple_one_for_one, max_restarts: 1_000_000)
  end

  @doc """
  Start camera worker
  """
  def start_worker(nil), do: :noop
  def start_worker(camera) do
    case get_config(camera) do
      {:ok, settings} ->
        Logger.debug "[#{settings.config.camera_exid}] Starting timelapse recording worker"
        Supervisor.start_child(__MODULE__, [settings])
      {:error, _message, url} ->
        Logger.warn "[#{camera.exid}] Skipping timelapse recording worker as the host is invalid: #{url}"
    end
  end

  @doc """
  Reinitialize timelapse recording worker with new configuration
  """
  def update_worker(nil, _camera), do: :noop
  def update_worker(worker, camera) do
    case get_config(camera) do
      {:ok, settings} ->
        Logger.debug "Updating timelapse recording worker for #{settings.config.camera_exid}"
        TimelapseRecordingWorker.update_config(worker, settings)
      {:error, _message} ->
        Logger.info "Skipping camera worker update as the host is invalid"
    end
  end

  @doc """
  Pause timelapse recording worker
  """
  def pause_worker(nil, _camera, _is_paused, _pause_seconds), do: :noop
  def pause_worker(worker, camera, is_paused, pause_seconds) do
    case get_config(camera, is_paused, pause_seconds) do
      {:ok, settings} ->
        Logger.debug "Paused timelapse recording worker for #{settings.config.camera_exid}"
        TimelapseRecordingWorker.update_config(worker, settings)
      {:error, _message} ->
        Logger.info "Skipping timelapse recording worker update as the host is invalid"
    end
  end

  @doc """
  update bucket path in timelapse recording worker
  """
  def update_path_worker(nil, _camera, _bucket_path), do: :noop
  def update_path_worker(worker, camera, bucket_path) do
    case get_config(camera, false, 5000, bucket_path) do
      {:ok, settings} ->
        Logger.debug "Update bucket path in worker: #{bucket_path}"
        TimelapseRecordingWorker.update_config(worker, settings)
      {:error, _message} ->
        Logger.info "Skipping timelapse recording worker update as the host is invalid"
    end
  end

  @doc """
  Start a timelapse recording workers for each camera in the database.

  This function is intended to be called after the EvercamMedia.TimelapseRecording.TimelapseRecordingSupervisor
  is initiated.
  """
  def initiate_workers do
    cameras = Camera.get_timelapse_recording_cameras
    Logger.info "Initiate timelapse recording workers (#{Enum.count(cameras)}) for snapshot recording."
    cameras |> Enum.map(&(start_worker &1))
  end

  @doc """
  Given a camera, it returns a map of values required for starting a timelapse recording worker.
  """
  def get_config(camera, is_paused \\ false, pause_seconds \\ 5000, bucket_path \\ "") do
    {
      :ok,
      %{
        name: "timelapse_#{camera.exid}" |> String.to_atom,
        config: %{
          camera_id: camera.id,
          camera_exid: camera.exid,
          vendor_exid: Camera.get_vendor_attr(camera, :exid),
          schedule: TimelapseRecording.schedule(camera.timelapse_recordings),
          recording: TimelapseRecording.recording(camera.timelapse_recordings),
          timezone: camera.timezone,
          url: Camera.hd_snapshot_url(camera),
          auth: Camera.auth(camera),
          sleep: TimelapseRecording.sleep(camera.timelapse_recordings),
          initial_sleep: TimelapseRecording.initial_sleep(camera.timelapse_recordings),
          bucket_path: get_bucket_path(camera.exid, bucket_path),
          is_paused: is_paused,
          pause_seconds: pause_seconds
        }
      }
    }
  end

  def get_bucket_path(camera_exid, ""), do: "#{camera_exid}/snapshots"
  def get_bucket_path(_camera_exid, bucket_path), do: bucket_path
end
